---
title: "Stage Two Randomization"
output: html_notebook
---

```{r libs, message = FALSE}
library(tidyverse)
```

```{r data, include = FALSE}
example_data <- read_csv("example_stage_one_data.csv")
possible_trt_sequences <- read_csv("possible_trt_sequences.csv")
```

```{r allocation_function}

#' Allocate patients to stage two treatments from a feasible set of treatments
#' which can depend on the initial treatment and the response status. The treatments
#' which are possible for stage 2 according to the stage 1 treatment is specified 
#' through a data frame where rows are valid treatment sequences and the two columns 
#' are A1 and A2. 
#' 
#' Switching rules are hard coded here
#' Good = maintain
#' Okay = stay or switch
#' bad = switch
#' What could be switched to is controlled by the trt.options.grid
#' 
#' @param df
#' @param trt.options.grid data frame where rows are valid treatment sequences and columns are stages
#' In contrast tot he trt.options.grid, the second stage treatments are augmentation treatments involving the treatment from A1
#' 
#' @return the original data frame with the second line treatment assignment column 
#' attached (column name A2)
RandomizeStageTwo <- function(df, trt.options.grid, max.single.trt.id, ...){
  stage2_feasible_trts_by_A1 <- trt.options.grid %>% 
    group_by(A1) %>%
    summarise(PossibleByA1 = list(unique(A2)),
              .groups = 'drop')
  
  # Expand the set of possibilities by response status, then apply the logic based on 
  # response status to define the feasible set for A2
  stage2_feasible_by_A1_resp_status <- stage2_feasible_trts_by_A1 %>% 
    expand_grid(respStatus = c("bad", "medium", "good", "excellent"), .) %>% 
    rowwise(.) %>% 
    mutate(FeasibleSet = case_when(respStatus == "excellent" ~ list(A1),
                                   respStatus == "good" ~ list(setdiff(PossibleByA1, 0:max.single.trt.id)),
                                   respStatus == "bad" ~ if_else(A1 == "0",
                                                                 list(setdiff(PossibleByA1, A1)),
                                                                 list(setdiff((1:max.single.trt.id), A1))),
                                   respStatus == "medium" ~ list(setdiff(PossibleByA1, A1)),
                                   TRUE ~ list("I Should be unreachable, investigate if you see me"))) %>% 
    select(-PossibleByA1)
  
  df_w_stage2_assignments <- left_join(df, stage2_feasible_by_A1_resp_status, by = c("A1", "respStatus")) %>% 
    rowwise %>% 
    mutate(A2 = sample(FeasibleSet, size = 1)) %>% 
    select(-FeasibleSet)
  
  return(df_w_stage2_assignments)
  
}
```


The possible treatment sequences are encoded in a two column matrix where the rows are 
feasible treatment sequences, the first column is the stage one treatment and the second column is the stage two treatment.
This enumerates all possible sequences of treatments in the study. 


```{r}
head(possible_trt_sequences)
```

Treatments have an ID number. For example:

0 means standard of care alone
7 means standard of care in combination with treatment A

0-3 are single treatments
4-9 are combination treatments

By filtering on the first stage treatment we can see all the feasible second stage treatments
```{r}
possible_trt_sequences %>% filter(A1 == 0) %>% pull(A2)
```

```{r}
head(example_data)
data_with_stage_two_treatments <- RandomizeStageTwo(df = example_data, trt.options.grid = possible_trt_sequences, max.single.trt.id = 3)
head(data_with_stage_two_treatments)
```

The protocol specifies constrained block randomization which isn't currently implemented in the code. But hopefully this is a useful starting point.